

### 待完成功能点
1、心跳及重连  y
2、客户端负载均衡   y
3、配置管理      y
3、接入阿里的hessian、google的protoful序列化

2019年11月28日23:34:29
完成功能：心跳及重连
思考（*代表优先级）：
1、当前模式使用的是异步模式，考虑新增回调函数代替返回future，但通过这种方式需要引入线程池来执行回调函数。*
    目前提供监听器的方式来添加方法回调接口，由RpcClient调用远程服务返回的是ResponseFuture来自动调起, 考虑到由于使用动态代理方式生成远程服务代理，
        1、在生成代理添加入参来设置方法回调规则，由于不同规则不同，需要使用字典的方式来匹配不同的方法。
        2、用户生成RpcClient后，通过RpcClient提供的接口来进来回调方法规则设置。
    以上两种方式的监听器的执行均由Netty IO线程触发，所以会占用IO线程，这点需要注意在监听器中不能执行可能阻塞、访问数据库等耗时较长的操作。
    * 考虑提供使用业务线程池来处理回调方法的接口。
2、当前配置过期混乱，重新思考配置封装后，引入yaml文件配置的方式来优化配置方案。  **
    技术选型：
        yaml：简单、可读性强的主流文件格式，被大多数优秀开源项目采用，如docker、k8s、kafka等。
        typesafe：支持superjson的配置文件格式，接口简单，支持从本地读取配置文件，但不支持配置bean反向持久化到配置文件的操作，需自己封装。
3、代码写得很垃圾！！！多看优秀项目的源码，重构！！！。*
4、当前想搞一套支持多种协议的RPC调用框架，但觉得还是应该从简到难，先完成各个独立功能，再考虑重构抽象出一套适用的框架。*
思考：
通讯层：网络通讯长连接需要注意的地方：心跳、超时处理、连接断开重连、服务端清除无效连接、关键日志
RPC调用层：效率、权限验证、身份校验、

睡了睡了，早睡早起的计划又泡汤了。

客户端代理对象 ***  已完成

通用私有协议设计 ***
0     1       2    3      4                    18      20     22       23     24
+-----+-------+----+------+--------------------+-------+-------+--------+-----+
|magic|version|type|switch|        sessionId           |timeout|protocol|codec|
+-----+-------+----+------+----------------------------+-------+--------+-----+
|   header  ...           |       body  ...                    |     crc      +
+-----+-------+----+------+--------------------+-------+-------+--------+-----+

magic 魔数，能快判断出当前请求消息是否合法，
version 版本号
type 消息类型，可能是request/response，也可能是heartbeat的msg/ack：
    request             00000001
    request_one_way     00000010
    response            00000011
    ctl                 00000100
    ctl_one_way         00000101        may will not use

switch 表示某些开关，crc校验
    00000001 crc校验
    00000010 ctl使用接口映射，提高传输效率
sessionId 当前消息会话id
timeout 请求超时时间
protocol datas协议类型，binary or serialize
codec serialize type,
    0x01 jdk
    0x02 hessian

header
    some option

data
    request  request
    response reponse
    ctl map or else


-----------------------------------------------------------------
思考了一下，为了一些机制以及考虑到一些字段可以意义不大，重新修改了一下协议设计，新的私有协议设计如下，request 及 response 通用
/**
 通用私有协议设计 ***
 REQUEST / RESPONSE             x         x            x                                        x
 0        1        2        3        4        5       6       7       8       9       10      11     12       13     14      15       16
 +--------+--------+--------+--------+--------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
 |  magic |protocol|version |  type  | switch |     timeout   |serial |               sessionId (16)     ...                          |
 +--------+--------+--------+--------+--------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
 |                     ...                            |    headLen    |    bodyLen    |                ...                            |
 +--------+--------+--------+--------+--------+-------+-------+-------+-------+-------+                                               +
 |                                                ...                                                                                 |
 +                              head                   +                    body                                                      +
 |                                               ...                                                                  |CRC32(optional)|
 +--------+--------+--------+--------+--------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
*/



vrpc机制设计
连接管理：
    url设计： vrpc://127.0.0.1:9527?poolSize=3&idleTimeout=60000 ...
    连接管理：连接数（reator主线程数、io线程数、IO线程是否共享）、连接预热选项、
    重连管理：重连间隔、重连次数
    选择策略：支持自定义选择策略
    连接事件监听：支持添加监听器方式监听连接事件、触发处理逻辑
    连接数据监控：成功数、失败数、平均响应时间、最大响应时间、最小响应时间等
    （后期功能：如果作为微服务，可考虑提供熔断等服务治理能力。）
    提供添加自定义解编码Handler接口

服务调用：
    同步阻塞调用
    异步Future调用
    异步CallBack调用（可配置处理器，由不同的线程池处理不同的远程命令如REQUEST、RESPONSE等）。采用这种模式，相当于添加监听器模式。
    单向请求（不需要返回响应、是否需要ack选项）

基础通信框架
    高级选项配置，如netty的高低水位、ChannelOptions等
    支持添加handler（这里的handler非二进制报文转换javaBean的handler，用户只需要更多的关注业务处理handler，因此这里添加的是业务相关的处理器）

自定义协议设计
    参考上边
    提供消息编解码接口及适配器、可通过Handler实现自定协议的消息传输。




模块设计：
客户端模块：
    1、协议
        编解码
    2、URL解析器
        url及配置
    3、连接管理器
        连接工厂：创建netty连接
        事件处理器：处理各种连接事件
        空闲及心跳触发器
        重连管理器
            重连策略：1、是否重连、重连间隔、次数、

    4、用户处理器：回调函数处理线程池
    ...

服务端模块：
    1、支持多协议，提供协议注册接口
    2、每种协议包含：
        1.1、自定义协议的编、解码规则
        1.2、消息处理器
        1.3、连接管理器
            连接工厂：监听服务端口
            事件处理器：处理各种连接事件
            空闲处理：关闭连接或发送心跳
            心跳触发器：
            重连管理器
                重连策略：1、是否重连、重连间隔、次数、

       - 1.4、IO处理线程池（version>2）

-------------------------------------------------------

2020-01-11 23:44:09
在实现过程中突然闪过新想法，从rpc -> RemotingClient -> protocol -> transport 各层接口定义不是很清晰，可重构
应用层 rpc
应用层 RemotingClient
协议层 protocol
传输层 transport

-------------------------------------------------------


2020-01-14 23:25:24 接口重构思考 「 修正中 」
client
rpc -------------------------> Remoting------------------------->  protocol ------------------------->  transport
rpc层：
    rpc层作为提供一个生成proxy对象的接口。
    client: 不关心底层通讯方式及其报文协议，只关心生成什么接口的代理实例、提供远程服务的url， 默认的请求超时时间。
    server: 同样不关心底层通讯方式及其报文协议，只关心当前绑定的ip、port，提供哪些接口的服务及其实例操作实现类（单例或多例？），处理请求的线程池配置
Remoting层：
    Remoting作为一个通用的远程通讯的框架，支持指定某个自定义的报文协议来进行通信.
    client: 提供同步调用、异步调用、添加回调函数（监听器）的接口进行远程请求，提供可配置的transport组件。
            关心：url、回调函数的处理线程池、传输协议、transport配置项
    server: 关心：url、transport配置项, 请求的处理线程池
protocol层（自定义成本较高，可考虑支持，但处理协议方式需要符合规范）：
    protocol层：报文协议设计、编解码、拆拼包（Remoting层收到的报文全部交由协议来处理），为Remoting层服务
Transport层
    提供远程连接建立、服务端口绑定、连接管理（连接池、断开重连、心跳，连接事件监听器），报文传输及接收、IO事件处理池绑定（考虑）


----------------------------------------------------
版本1优化点记录
1、客户端invoke接口，添加InvokeContext(响应、超时、crc选项、等)
2、服务端添加可配置业务处理线程池、业务处理任务接口
3、协议与序列化解码，那么需要提供序列化协议注册管理（版本1）

----------------------------------------------------
https://mp.weixin.qq.com/s/JRsbK1Un2av9GKmJ8DK7IQ
非常感谢阿里公众号这篇文章的帮助，使我对通信框架的设计思路更加清晰了。

